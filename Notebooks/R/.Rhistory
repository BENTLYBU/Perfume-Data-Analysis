target_audience = case_when(
tolower(target_audience) %in% c("male","men") ~ "Male",
tolower(target_audience) %in% c("female","women") ~ "Female",
TRUE ~ "Unisex"
),
target_audience = factor(target_audience)
) %>%
select(category, type, target_audience) %>%
filter(!is.na(category), !is.na(type))
# 分割训练集/测试集
set.seed(123)
trainIndex <- createDataPartition(df_ml$target_audience, p = 0.7, list = FALSE)
train <- df_ml[trainIndex, ]
test  <- df_ml[-trainIndex, ]
# ===== 模型训练（随机森林） =====
set.seed(123)
rf_model <- randomForest(target_audience ~ category + type, data=train, ntree=500, importance=TRUE)
print(rf_model)
# ===== 模型预测与评估 =====
pred <- predict(rf_model, test)
confusion <- confusionMatrix(pred, test$target_audience)
print(confusion)
# ===== 特征重要性 =====
importance(rf_model)
varImpPlot(rf_model, main="Feature Importance: Category vs Type")
# ====== A) Gender × Category ======
tab_cat <- table(perfume$target_audience, perfume$category)
# 卡方检验
chi_cat <- chisq.test(tab_cat)
print(chi_cat)
# Cramer's V
cramer_v_cat <- sqrt(chi_cat$statistic / (sum(tab_cat) * (min(dim(tab_cat)) - 1)))
cat("Cramer's V (Gender × Category):", cramer_v_cat, "\n")
# 残差矩阵转长表
resid_cat <- as.data.frame(as.table(chi_cat$residuals))
colnames(resid_cat) <- c("Gender", "Category", "Residual")
# Top 20 绝对残差
top20_resid_cat <- resid_cat %>%
arrange(desc(abs(Residual))) %>%
slice_head(n = 20)
# 可视化：残差条形图
ggplot(top20_resid_cat, aes(x = reorder(paste(Category, Gender, sep=" - "), abs(Residual)),
y = Residual, fill = Residual > 0)) +
geom_col(width = 0.7) +
coord_flip() +
scale_fill_manual(values=c("TRUE"="steelblue","FALSE"="tomato"),
labels=c("FALSE"="Under-represented","TRUE"="Over-represented")) +
labs(title="Top 20 Residuals: Gender × Category",
x="Category - Gender", y="Pearson Residual", fill="Interpretation") +
theme_minimal(base_size=13)
knitr::opts_chunk$set(
echo = TRUE,     # 默认显示代码
message = FALSE,  # 不显示 library 的加载信息
warning = FALSE   # 不显示警告
)
# Define function to check is package is installed
install_if_missing <- function(pkg){
if (!require(pkg, character.only = TRUE)) {
install.packages(pkg, dependencies = TRUE, repos = "https://cloud.r-project.org/")
library(pkg, character.only = TRUE)
}
}
# Install and load library
pkgs <- c("readr","dplyr","tidyr","stringr","janitor","ggplot2","ggrepel","scales","plotly","tibble","vcd","caret","randomForest")
invisible(lapply(pkgs, install_if_missing))
# Read in csv
perfume <- read.csv("../../Data/Perfumes_dataset.csv")
# Standardize
perfume <- perfume |>
janitor::clean_names() |>
dplyr::mutate(
brand           = stringr::str_squish(brand),
perfume         = stringr::str_squish(perfume),
type            = stringr::str_squish(stringr::str_to_lower(type)),        # e.g. "edp", "edt"
category        = stringr::str_squish(stringr::str_to_title(category)),    # "Fresh Scent" etc.
target_audience = stringr::str_squish(stringr::str_to_title(target_audience)), # "Male/Female/Unisex"
longevity       = stringr::str_squish(stringr::str_to_title(longevity))    # "Strong/Medium/..."
)
perfume[1:10,]
glimpse(perfume)
summary(perfume)
# Find number of unique value in each column
sapply(perfume, function(x) length(unique(x)))
count_share <- function(df, group_vars)
{ df |>
dplyr::count(dplyr::across({{ group_vars }}), name = "n") |>
dplyr::mutate(share = n / sum(n)) |> dplyr::arrange(dplyr::desc(n))
}
market_share_all <- count_share(perfume, target_audience)
market_share_all_fixed <- market_share_all %>%
mutate(target_audience = recode(target_audience, "Men" = "Male", "Women" = "Female")) %>%
group_by(target_audience) %>%
summarise(n = sum(n), .groups = "drop") %>%
mutate(share = n / sum(n)) %>%
arrange(desc(n))
print(market_share_all_fixed)
# Group Women and female, male and men.
# Example data (replace with your actual counts/shares)
audience_share <- data.frame(
target_audience = c("Male", "Female", "Unisex"),
share = c(0.295, 0.330, 0.374)
)
# Ensure factor levels in the right order
audience_share <- audience_share %>%
mutate(target_audience = factor(target_audience, levels = c("Male","Female","Unisex")))
# Pie chart
ggplot(audience_share, aes(x = "", y = share, fill = target_audience)) +
geom_col(width = 1, color = "white") +
coord_polar(theta = "y") +
geom_text(aes(label = percent(share, accuracy = 0.1)),
position = position_stack(vjust = 0.5), size = 5) +
scale_fill_manual(
values = c("Male" = "tomato", "Female" = "seagreen3", "Unisex" = "steelblue")
) +
labs(title = "Market Share of Fragrances by Target Audience",
fill = "Target Audience") +
theme_void(base_size = 14)
#Large variance show the difference inside a category and shared range indicates the range of difference inside one category. Based on these two standerds, we can Select k brands that are most differentiated. With the help of heatmap, we can clearly see the dominance of the market share of these brands on gender difference.
perfume <- perfume %>%
janitor::clean_names() %>%
mutate(
category        = str_squish(str_to_title(category)),
target_audience = str_squish(str_to_title(target_audience))
) %>%
filter(target_audience %in% c("Male","Female","Unisex"),
!is.na(category), category != "")
# ====== 统计：性别 x 类别（数量 + 类别内占比）======
heat_df <- perfume %>%
count(target_audience, category, name = "n") %>%
group_by(category) %>%
mutate(share = n / sum(n)) %>%
ungroup()
# ====== 工具函数：选择“有代表性”的类别 ======
# method:
# - "top_total": 选总量最高的前 k 个类别
# - "most_divergent": 选性别占比差异（方差/极差）最大的前 k 个类别
select_categories <- function(df, k = 20, method = c("top_total","most_divergent")){
method <- match.arg(method)
wide <- df %>%
select(category, target_audience, n, share) %>%
pivot_wider(names_from = target_audience, values_from = c(n, share), values_fill = 0)
if (method == "top_total"){
picked <- wide %>%
mutate(total_n = rowSums(across(starts_with("n_")))) %>%
arrange(desc(total_n)) %>%
slice_head(n = min(k, nrow(.))) %>%
pull(category)
} else {
# 用“占比”的方差 + 极差 作为“差异度”打分
picked <- wide %>%
transmute(
category,
var_share  = apply(across(starts_with("share_")), 1, var),
range_share = apply(across(starts_with("share_")), 1, function(x) diff(range(x)))
) %>%
mutate(score = 0.5*var_share + 0.5*range_share) %>%
arrange(desc(score)) %>%
slice_head(n = min(k, nrow(.))) %>%
pull(category)
}
picked
}
# ====== 工具函数：聚类/排序列顺序（让热力图更有结构）======
# 对类别×性别矩阵做层次聚类，返回类别顺序
cluster_category_order <- function(df, use = c("n","share")){
use <- match.arg(use)
mat <- df %>%
select(category, target_audience, !!sym(use)) %>%
pivot_wider(names_from = target_audience, values_from = !!sym(use), values_fill = 0) %>%
column_to_rownames("category") %>%
as.matrix()
# 用相关距离或欧式距离都可；占比用欧式通常够用
d <- dist(scale(mat, center = TRUE, scale = TRUE), method = "euclidean")
hc <- hclust(d, method = "ward.D2")
rownames(mat)[hc$order]
}
# ====== 主函数：画交互热力图（plotly）======
# metric: "count" 或 "share"
# pick_method: "top_total" 或 "most_divergent"
# k: 展示的类别数量
# cluster: 是否聚类排序
plot_heatmap_q1 <- function(df = heat_df,
metric = c("count","share"),
pick_method = c("top_total","most_divergent"),
k = 20,
cluster = TRUE){
metric <- match.arg(metric)
pick_method <- match.arg(pick_method)
metric_col <- if (metric == "count") "n" else "share"
cats <- select_categories(df, k = k, method = pick_method)
df_sub <- df %>% filter(category %in% cats)
# 列顺序
if (cluster){
cat_order <- cluster_category_order(df_sub, use = if(metric=="count") "n" else "share")
} else {
# 非聚类时：按总量降序排
cat_order <- df_sub %>%
group_by(category) %>%
summarise(tot = sum(.data[[metric_col]]), .groups = "drop") %>%
arrange(desc(tot)) %>%
pull(category)
}
# 组装矩阵和 hover 文本
mat <- df_sub %>%
mutate(category = factor(category, levels = cat_order),
target_audience = factor(target_audience, levels = c("Male","Female","Unisex"))) %>%
arrange(target_audience, category) %>%
select(category, target_audience, !!sym(metric_col)) %>%
pivot_wider(names_from = category, values_from = !!sym(metric_col), values_fill = 0) %>%
column_to_rownames("target_audience") %>%
as.matrix()
# hover 信息：同时显示 count 和 share
hover_df <- df_sub %>%
mutate(category = factor(category, levels = cat_order),
target_audience = factor(target_audience, levels = c("Male","Female","Unisex"))) %>%
arrange(target_audience, category) %>%
select(category, target_audience, n, share) %>%
pivot_wider(names_from = category, values_from = c(n, share), values_fill = 0)
# 生成和 mat 同维度的 hovertext
audience_levels <- rownames(mat)
hovertext <- matrix("", nrow = nrow(mat), ncol = ncol(mat))
for (i in seq_along(audience_levels)){
aud <- audience_levels[i]
n_vec     <- as.numeric(hover_df %>% filter(target_audience == aud) %>% select(starts_with("n_")) )
share_vec <- as.numeric(hover_df %>% filter(target_audience == aud) %>% select(starts_with("share_")) )
hovertext[i, ] <- paste0(
"Category: ", colnames(mat), "<br>",
"Audience: ", aud, "<br>",
"Count: ", n_vec, "<br>",
"Share-in-Category: ", scales::percent(share_vec, accuracy = 0.1)
)
}
# 颜色条标题
colorbar_title <- if (metric == "count") "Count" else "Share"
# 画图
plotly::plot_ly(
x = colnames(mat), y = rownames(mat),
z = mat,
type = "heatmap",
colors = "Blues",            # 连续色标
hoverinfo = "text",
text = hovertext,
showscale = TRUE,
colorbar = list(title = colorbar_title)
) %>%
layout(
title = paste0("Gender × Category Heatmap (metric: ", colorbar_title,
", pick: ", pick_method, ", k=", k, if (cluster) ", clustered" else "" ,")"),
xaxis = list(title = "Category", tickangle = 40, automargin = TRUE),
yaxis = list(title = "Target Audience", automargin = TRUE)
)
}
# ====== 调用示例 ======
# 1) 用“数量”作图，选“最有差异”的 20 个类别，并做聚类排序
p1 <- plot_heatmap_q1(metric = "count", pick_method = "most_divergent", k = 20, cluster = TRUE)
p1
# ====== A) Gender × Category ======
tab_cat <- table(perfume$target_audience, perfume$category)
# 卡方检验
chi_cat <- chisq.test(tab_cat)
print(chi_cat)
# Cramer's V
cramer_v_cat <- sqrt(chi_cat$statistic / (sum(tab_cat) * (min(dim(tab_cat)) - 1)))
cat("Cramer's V (Gender × Category):", cramer_v_cat, "\n")
# 残差矩阵转长表
resid_cat <- as.data.frame(as.table(chi_cat$residuals))
colnames(resid_cat) <- c("Gender", "Category", "Residual")
# Top 20 绝对残差
top20_resid_cat <- resid_cat %>%
arrange(desc(abs(Residual))) %>%
slice_head(n = 20)
# 可视化：残差条形图
ggplot(top20_resid_cat, aes(x = reorder(paste(Category, Gender, sep=" - "), abs(Residual)),
y = Residual, fill = Residual > 0)) +
geom_col(width = 0.7) +
coord_flip() +
scale_fill_manual(values=c("TRUE"="steelblue","FALSE"="tomato"),
labels=c("FALSE"="Under-represented","TRUE"="Over-represented")) +
labs(title="Top 20 Residuals: Gender × Category",
x="Category - Gender", y="Pearson Residual", fill="Interpretation") +
theme_minimal(base_size=13)
knitr::opts_chunk$set(
echo = TRUE,     # 默认显示代码
message = FALSE,  # 不显示 library 的加载信息
warning = FALSE   # 不显示警告
)
# Define function to check is package is installed
install_if_missing <- function(pkg){
if (!require(pkg, character.only = TRUE)) {
install.packages(pkg, dependencies = TRUE, repos = "https://cloud.r-project.org/")
library(pkg, character.only = TRUE)
}
}
# Install and load library
pkgs <- c("readr","dplyr","tidyr","stringr","janitor","ggplot2","ggrepel","scales","plotly","tibble","vcd","caret","randomForest")
invisible(lapply(pkgs, install_if_missing))
# Read in csv
perfume <- read.csv("../../Data/Perfumes_dataset.csv")
# Standardize
perfume <- perfume |>
janitor::clean_names() |>
dplyr::mutate(
brand           = stringr::str_squish(brand),
perfume         = stringr::str_squish(perfume),
type            = stringr::str_squish(stringr::str_to_lower(type)),        # e.g. "edp", "edt"
category        = stringr::str_squish(stringr::str_to_title(category)),    # "Fresh Scent" etc.
target_audience = stringr::str_squish(stringr::str_to_title(target_audience)), # "Male/Female/Unisex"
longevity       = stringr::str_squish(stringr::str_to_title(longevity))    # "Strong/Medium/..."
)
perfume[1:10,]
glimpse(perfume)
summary(perfume)
# Find number of unique value in each column
sapply(perfume, function(x) length(unique(x)))
count_share <- function(df, group_vars)
{ df |>
dplyr::count(dplyr::across({{ group_vars }}), name = "n") |>
dplyr::mutate(share = n / sum(n)) |> dplyr::arrange(dplyr::desc(n))
}
market_share_all <- count_share(perfume, target_audience)
market_share_all_fixed <- market_share_all %>%
mutate(target_audience = recode(target_audience, "Men" = "Male", "Women" = "Female")) %>%
group_by(target_audience) %>%
summarise(n = sum(n), .groups = "drop") %>%
mutate(share = n / sum(n)) %>%
arrange(desc(n))
print(market_share_all_fixed)
# Group Women and female, male and men.
# Example data (replace with your actual counts/shares)
audience_share <- data.frame(
target_audience = c("Male", "Female", "Unisex"),
share = c(0.295, 0.330, 0.374)
)
# Ensure factor levels in the right order
audience_share <- audience_share %>%
mutate(target_audience = factor(target_audience, levels = c("Male","Female","Unisex")))
# Pie chart
ggplot(audience_share, aes(x = "", y = share, fill = target_audience)) +
geom_col(width = 1, color = "white") +
coord_polar(theta = "y") +
geom_text(aes(label = percent(share, accuracy = 0.1)),
position = position_stack(vjust = 0.5), size = 5) +
scale_fill_manual(
values = c("Male" = "tomato", "Female" = "seagreen3", "Unisex" = "steelblue")
) +
labs(title = "Market Share of Fragrances by Target Audience",
fill = "Target Audience") +
theme_void(base_size = 14)
#Large variance show the difference inside a category and shared range indicates the range of difference inside one category. Based on these two standerds, we can Select k brands that are most differentiated. With the help of heatmap, we can clearly see the dominance of the market share of these brands on gender difference.
perfume <- perfume %>%
janitor::clean_names() %>%
mutate(
category        = str_squish(str_to_title(category)),
target_audience = str_squish(str_to_title(target_audience))
) %>%
filter(target_audience %in% c("Male","Female","Unisex"),
!is.na(category), category != "")
# ====== 统计：性别 x 类别（数量 + 类别内占比）======
heat_df <- perfume %>%
count(target_audience, category, name = "n") %>%
group_by(category) %>%
mutate(share = n / sum(n)) %>%
ungroup()
# ====== 工具函数：选择“有代表性”的类别 ======
# method:
# - "top_total": 选总量最高的前 k 个类别
# - "most_divergent": 选性别占比差异（方差/极差）最大的前 k 个类别
select_categories <- function(df, k = 20, method = c("top_total","most_divergent")){
method <- match.arg(method)
wide <- df %>%
select(category, target_audience, n, share) %>%
pivot_wider(names_from = target_audience, values_from = c(n, share), values_fill = 0)
if (method == "top_total"){
picked <- wide %>%
mutate(total_n = rowSums(across(starts_with("n_")))) %>%
arrange(desc(total_n)) %>%
slice_head(n = min(k, nrow(.))) %>%
pull(category)
} else {
# 用“占比”的方差 + 极差 作为“差异度”打分
picked <- wide %>%
transmute(
category,
var_share  = apply(across(starts_with("share_")), 1, var),
range_share = apply(across(starts_with("share_")), 1, function(x) diff(range(x)))
) %>%
mutate(score = 0.5*var_share + 0.5*range_share) %>%
arrange(desc(score)) %>%
slice_head(n = min(k, nrow(.))) %>%
pull(category)
}
picked
}
# ====== 工具函数：聚类/排序列顺序（让热力图更有结构）======
# 对类别×性别矩阵做层次聚类，返回类别顺序
cluster_category_order <- function(df, use = c("n","share")){
use <- match.arg(use)
mat <- df %>%
select(category, target_audience, !!sym(use)) %>%
pivot_wider(names_from = target_audience, values_from = !!sym(use), values_fill = 0) %>%
column_to_rownames("category") %>%
as.matrix()
# 用相关距离或欧式距离都可；占比用欧式通常够用
d <- dist(scale(mat, center = TRUE, scale = TRUE), method = "euclidean")
hc <- hclust(d, method = "ward.D2")
rownames(mat)[hc$order]
}
# ====== 主函数：画交互热力图（plotly）======
# metric: "count" 或 "share"
# pick_method: "top_total" 或 "most_divergent"
# k: 展示的类别数量
# cluster: 是否聚类排序
plot_heatmap_q1 <- function(df = heat_df,
metric = c("count","share"),
pick_method = c("top_total","most_divergent"),
k = 20,
cluster = TRUE){
metric <- match.arg(metric)
pick_method <- match.arg(pick_method)
metric_col <- if (metric == "count") "n" else "share"
cats <- select_categories(df, k = k, method = pick_method)
df_sub <- df %>% filter(category %in% cats)
# 列顺序
if (cluster){
cat_order <- cluster_category_order(df_sub, use = if(metric=="count") "n" else "share")
} else {
# 非聚类时：按总量降序排
cat_order <- df_sub %>%
group_by(category) %>%
summarise(tot = sum(.data[[metric_col]]), .groups = "drop") %>%
arrange(desc(tot)) %>%
pull(category)
}
# 组装矩阵和 hover 文本
mat <- df_sub %>%
mutate(category = factor(category, levels = cat_order),
target_audience = factor(target_audience, levels = c("Male","Female","Unisex"))) %>%
arrange(target_audience, category) %>%
select(category, target_audience, !!sym(metric_col)) %>%
pivot_wider(names_from = category, values_from = !!sym(metric_col), values_fill = 0) %>%
column_to_rownames("target_audience") %>%
as.matrix()
# hover 信息：同时显示 count 和 share
hover_df <- df_sub %>%
mutate(category = factor(category, levels = cat_order),
target_audience = factor(target_audience, levels = c("Male","Female","Unisex"))) %>%
arrange(target_audience, category) %>%
select(category, target_audience, n, share) %>%
pivot_wider(names_from = category, values_from = c(n, share), values_fill = 0)
# 生成和 mat 同维度的 hovertext
audience_levels <- rownames(mat)
hovertext <- matrix("", nrow = nrow(mat), ncol = ncol(mat))
for (i in seq_along(audience_levels)){
aud <- audience_levels[i]
n_vec     <- as.numeric(hover_df %>% filter(target_audience == aud) %>% select(starts_with("n_")) )
share_vec <- as.numeric(hover_df %>% filter(target_audience == aud) %>% select(starts_with("share_")) )
hovertext[i, ] <- paste0(
"Category: ", colnames(mat), "<br>",
"Audience: ", aud, "<br>",
"Count: ", n_vec, "<br>",
"Share-in-Category: ", scales::percent(share_vec, accuracy = 0.1)
)
}
# 颜色条标题
colorbar_title <- if (metric == "count") "Count" else "Share"
# 画图
plotly::plot_ly(
x = colnames(mat), y = rownames(mat),
z = mat,
type = "heatmap",
colors = "Blues",            # 连续色标
hoverinfo = "text",
text = hovertext,
showscale = TRUE,
colorbar = list(title = colorbar_title)
) %>%
layout(
title = paste0("Gender × Category Heatmap (metric: ", colorbar_title,
", pick: ", pick_method, ", k=", k, if (cluster) ", clustered" else "" ,")"),
xaxis = list(title = "Category", tickangle = 40, automargin = TRUE),
yaxis = list(title = "Target Audience", automargin = TRUE)
)
}
# ====== 调用示例 ======
# 1) 用“数量”作图，选“最有差异”的 20 个类别，并做聚类排序
p1 <- plot_heatmap_q1(metric = "count", pick_method = "most_divergent", k = 20, cluster = TRUE)
p1
# ====== A) Gender × Category ======
tab_cat <- table(perfume$target_audience, perfume$category)
# 卡方检验
chi_cat <- chisq.test(tab_cat)
print(chi_cat)
# Cramer's V
cramer_v_cat <- sqrt(chi_cat$statistic / (sum(tab_cat) * (min(dim(tab_cat)) - 1)))
cat("Cramer's V (Gender × Category):", cramer_v_cat, "\n")
# 残差矩阵转长表
resid_cat <- as.data.frame(as.table(chi_cat$residuals))
colnames(resid_cat) <- c("Gender", "Category", "Residual")
# Top 20 绝对残差
top20_resid_cat <- resid_cat %>%
arrange(desc(abs(Residual))) %>%
slice_head(n = 20)
# 可视化：残差条形图
ggplot(top20_resid_cat, aes(x = reorder(paste(Category, Gender, sep=" - "), abs(Residual)),
y = Residual, fill = Residual > 0)) +
geom_col(width = 0.7) +
coord_flip() +
scale_fill_manual(values=c("TRUE"="steelblue","FALSE"="tomato"),
labels=c("FALSE"="Under-represented","TRUE"="Over-represented")) +
labs(title="Top 20 Residuals: Gender × Category",
x="Category - Gender", y="Pearson Residual", fill="Interpretation") +
theme_minimal(base_size=13)
